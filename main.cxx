#include "x86internals.h" // Include the header generated by FLUID
#include <FL/Fl.H>        // Required for Fl::run()
#include <iomanip>
#include <iostream>
#include <sstream>
#include <string>
#include <vector>

X86Internals x86internals;

std::vector<GDTEntry> parse_gdt_from_hex(const std::string &hex) {
  std::vector<GDTEntry> entries;

  // Remove any whitespace
  std::string clean;
  for (char c : hex) {
    if (!isspace(c))
      clean += c;
  }

  // Must be a multiple of 16 hex chars (8 bytes per GDT entry)
  if (clean.size() % 16 != 0) {
    std::cerr << "Invalid hex length for GDT entries.\n";
    return entries;
  }

  for (size_t i = 0; i < clean.size(); i += 16) {
    std::string chunk = clean.substr(i, 16);
    uint64_t raw = std::stoull(chunk, nullptr, 16);

    GDTEntry entry;
    entry.limit = (raw & 0xFFFF) | (((raw >> 48) & 0xF) << 16);
    entry.base = ((raw >> 16) & 0xFFFFFF) | (((raw >> 56) & 0xFF) << 24);
    entry.access = (raw >> 40) & 0xFF;
    entry.flags = (raw >> 52) & 0xF;

    entries.push_back(entry);
  }

  return entries;
}

std::string format_gdt_entries(const std::vector<GDTEntry> &entries) {
  std::ostringstream out;
  int i = 0;
  for (const auto &e : entries) {
    out << "Entry " << i++ << ": "
        << "Base=0x" << std::hex << std::setw(8) << std::setfill('0') << e.base
        << ", Limit=0x" << std::setw(5) << e.limit << ", Access=0x"
        << std::setw(2) << static_cast<int>(e.access) << ", Flags=0x"
        << static_cast<int>(e.flags) << "\n";
  }
  return out.str();
}

void Button_CB(Fl_Button *w, void *user_data) {
  const char *hex = x86internals.hex_input->value();

  std::string displayText;
  switch (x86internals.x86_structs->value()) {
  case 0: {
    // Parse input into GDT
    auto entries = parse_gdt_from_hex(hex);
    displayText = format_gdt_entries(entries);
    break;
  }
  default:
    displayText = "Not implemented yet.";
    break;
  }

  // Replace buffer with parsed GDT text
  Fl_Text_Buffer *old_buf = x86internals.internal_struct->buffer();
  if (old_buf != nullptr) {
    x86internals.internal_struct->buffer(nullptr); // disconnect safely
    delete old_buf;
  }

  Fl_Text_Buffer *buf = new Fl_Text_Buffer;
  buf->text(displayText.c_str());
  x86internals.internal_struct->buffer(buf);
  x86internals.internal_struct->redraw();
}

void Choice_CB(Fl_Choice *w, void *user_data) {
  std::cout << "Choice event" << std::endl;
  const char *selected_text = w->text();
  int selected_index = w->value();
#if DEBUG
  std::cout << "Selected: " << selected_text << " (Index: " << selected_index
            << ")" << std::endl;
#endif
  std::vector<std::string> titles{"Global Descriptor Table",
                                  "Local Descriptor Table",
                                  "Interrupt Descriptor Table"};

  // Update the displayed text label.
  x86internals.title_box->copy_label(titles[selected_index].c_str());
  x86internals.title_box->redraw_label();
}

int main(int argc, char **argv) {
  // Initialize FLTK
  Fl::args(argc, argv);
  // Fl::set_locale();

  // Call the function generated by FLUID to create your main window
  Fl_Window *main_window =
      x86internals.make_main_window(); // Assuming 'make_main_window()' is
                                       // generated by FLUID
  x86internals.x86_structs->add("GDT");
  x86internals.x86_structs->add("LDT");
  x86internals.x86_structs->add("IDT");
  // Show the window
  main_window->show(argc, argv);

  // Start the FLTK event loop
  return Fl::run();
}

#include "x86internals.h" // Include the header generated by FLUID
#include <FL/Fl.H>        // Required for Fl::run()
#include <iomanip>
#include <iostream>
#include <sstream>
#include <string>
#include <vector>

X86Internals x86internals;

bool isValidHex(const std::string &str) {
  if (str.empty()) {
    return false; // An empty string is not a valid hex number
  }
  for (char c : str) {
    if (!std::isxdigit(static_cast<unsigned char>(c))) {
      return false; // Character is not a hexadecimal digit
    }
  }
  return true; // All characters are valid hexadecimal digits
}

std::vector<GDTEntry> parse_gdt_from_hex(const std::string &hex) {
  std::vector<GDTEntry> entries;

  // Remove any whitespace
  std::string trimmed, clean;
  for (char c : hex) {
    if (!isspace(c))
      trimmed += c;
  }

  // Remove "0x" or "0X"
  if (trimmed[0] == '0' && std::tolower(trimmed[1]) == 'x')
    clean = trimmed.substr(2);
  else
    clean = trimmed;

  // Must be a valid hex num.
  if (!isValidHex(clean)) {
    return entries;
  }

  // Must be a multiple of 16 hex chars (8 bytes per GDT entry)
  if (clean.size() % 16 != 0) {
    std::cerr << "Invalid hex length for GDT entries.\n";
    return entries;
  }

  for (size_t i = 0; i < clean.size(); i += 16) {
    std::string chunk = clean.substr(i, 16);
    uint64_t raw = std::stoull(chunk, nullptr, 16);

    GDTEntry entry;
    entry.limit = (raw & 0xFFFF) | (((raw >> 48) & 0xF) << 16);
    entry.base = ((raw >> 16) & 0xFFFFFF) | (((raw >> 56) & 0xFF) << 24);
    entry.access.value = (raw >> 40) & 0xFF;
    entry.flags.value = (raw >> 52) & 0xF;

    entries.push_back(entry);
  }

  return entries;
}

std::string format_gdt_entries(const std::vector<GDTEntry> &entries) {
  std::ostringstream out;
  int i = 0;
  for (const auto &e : entries) {
    int len = e.limit + 1;
    if (e.flags.bits.G == 1)
      len *= 4096;
    std::string len_dec, seg_type, seg_common;
    int tmp, len2 = len;
    if (tmp = len2 / (1024 * 1024 * 1024)) {
      len_dec += std::to_string(tmp) + " GB ";
      len2 %= (1024 * 1024 * 1024);
    }
    if (tmp = len2 / (1024 * 1024)) {
      len_dec += std::to_string(tmp) + " MB ";
      len2 %= (1024 * 1024);
    }
    if (tmp = len2 / (1024)) {
      len_dec += std::to_string(tmp) + " KB ";
      len2 %= (1024);
    }
    if (len2) {
      len_dec += std::to_string(len2) + " B ";
    }

    seg_common += ": Ring " + std::to_string(e.access.bits.DPL);
    if (e.access.bits.P)
      seg_common += " In Memory";
    else
      seg_common += " Not in Memory";

    if (!e.access.bits.S) {
      if (e.access.bits.TYPE & 0x9 && e.access.bits.TYPE | 0x4)
        seg_type = "TSS: " + seg_common;
      else if (e.access.bits.TYPE == 0x2)
        seg_type = "LDT: " + seg_common;
      else
        seg_type = "System: " + seg_common;
    } else {
      if (e.access.bits.TYPE & 0x8) {
        seg_type = "Code: " + seg_common;
        if (e.access.bits.TYPE & 0x2)
          seg_type += ": Readable";
        if (e.access.bits.TYPE & 0x1)
          seg_type += ": Accessed";
      } else {
        seg_type = "Data: " + seg_common;
        if (e.access.bits.TYPE & 0x2)
          seg_type += ": Writable";
        if (e.access.bits.TYPE & 0x1)
          seg_type += ": Accessed";
      }
    }

    out << "Entry " << i++ << ": "
        << "Base=0x" << std::hex << std::setw(8) << std::setfill('0') << e.base
        << ", Limit=0x" << std::setw(5) << e.limit << ", Access=0x"
        << std::setw(2) << static_cast<int>(e.access.value) << ", Flags=0x"
        << static_cast<int>(e.flags.value) << "\n"
        << "Segment Length=0x" << len << " ( " << len_dec << ")\n"
        << "Segment Type=" << seg_type << "\n";
  }
  return out.str();
}

std::vector<IDTEntry> parse_idt_from_hex(const std::string &hex) {
  std::vector<IDTEntry> entries;

  // Remove any whitespace
  std::string trimmed, clean;
  for (char c : hex) {
    if (!isspace(c))
      trimmed += c;
  }

  // Remove "0x" or "0X"
  if (trimmed[0] == '0' && std::tolower(trimmed[1]) == 'x')
    clean = trimmed.substr(2);
  else
    clean = trimmed;

  // Must be a valid hex num.
  if (!isValidHex(clean)) {
    return entries;
  }

  // Must be a multiple of 16 hex chars (8 bytes per IDT entry)
  if (clean.size() % 16 != 0) {
    std::cerr << "Invalid hex length for IDT entries.\n";
    return entries;
  }

  for (size_t i = 0; i < clean.size(); i += 16) {
    std::string chunk = clean.substr(i, 16);
    uint64_t raw = std::stoull(chunk, nullptr, 16);
    // Not a valid IDT entry.
    if (((raw >> 40) & 0x1E) != 0xE)
      return entries;

    IDTEntry entry;
    entry.offset = (raw & 0xFFFF) | (((raw >> 48) & 0xFFFF) << 16);
    entry.segment = (raw >> 16) & 0xFFFF;
    entry.access.value = (raw >> 40) & 0xFF;

    entries.push_back(entry);
  }

  return entries;
}

std::string format_idt_entries(const std::vector<IDTEntry> &entries) {
  std::ostringstream out;
  int i = 0;
  for (const auto &e : entries) {
    std::string len_dec, seg_type, seg_common;
    seg_common += ": Ring " + std::to_string(e.access.bits.DPL);
    if (e.access.bits.P)
      seg_common += " In Memory";
    else
      seg_common += " Not in Memory";

    if (e.access.bits.TYPE == 0xE)
      seg_type = "Interrupt Gate: " + seg_common;
    else if (e.access.bits.TYPE == 0xF)
      seg_type = "Trap Gate: " + seg_common;
    else if (e.access.bits.TYPE == 0x5)
      seg_type = "Task Gate: " + seg_common;

    out << "Entry " << i++ << ": "
        << "Offset=0x" << std::hex << std::setw(8) << std::setfill('0')
        << e.offset << ", Segment=0x" << std::setw(5) << e.segment
        << ", Access=0x" << std::setw(2) << static_cast<int>(e.access.value)
        << "\n"
        << "Type: " << seg_type;
  }
  return out.str();
}

void Button_CB(Fl_Button *w, void *user_data) {
  const char *hex = x86internals.hex_input->value();

  std::string displayText;
  switch (x86internals.x86_structs->value()) {
  case 0: {
    // Parse input into GDT
    auto entries = parse_gdt_from_hex(hex);
    if (entries.empty())
      displayText = "Invalid input. Please check it.";
    else
      displayText = format_gdt_entries(entries);
    break;
  }
  case 2: {
    // Parse input into IDT
    auto entries = parse_idt_from_hex(hex);
    if (entries.empty())
      displayText = "Invalid input. Please check it.";
    else
      displayText = format_idt_entries(entries);
    break;
  }
  default:
    displayText = "Not implemented yet.";
    break;
  }

  // Replace buffer with parsed GDT text
  Fl_Text_Buffer *old_buf = x86internals.internal_struct->buffer();
  if (old_buf != nullptr) {
    x86internals.internal_struct->buffer(nullptr); // disconnect safely
    delete old_buf;
  }

  Fl_Text_Buffer *buf = new Fl_Text_Buffer;
  buf->text(displayText.c_str());
  x86internals.internal_struct->buffer(buf);
  x86internals.internal_struct->redraw();
}

void Choice_CB(Fl_Choice *w, void *user_data) {
  std::cout << "Choice event" << std::endl;
  const char *selected_text = w->text();
  int selected_index = w->value();
#if DEBUG
  std::cout << "Selected: " << selected_text << " (Index: " << selected_index
            << ")" << std::endl;
#endif
  std::vector<std::string> titles{"Global Descriptor Table",
                                  "Local Descriptor Table",
                                  "Interrupt Descriptor Table"};

  // Update the displayed text label.
  x86internals.title_box->copy_label(titles[selected_index].c_str());
  x86internals.title_box->redraw_label();
}

int main(int argc, char **argv) {
  // Initialize FLTK
  Fl::args(argc, argv);
  // Fl::set_locale();

  // Call the function generated by FLUID to create your main window
  Fl_Window *main_window =
      x86internals.make_main_window(); // Assuming 'make_main_window()' is
                                       // generated by FLUID
  x86internals.x86_structs->add("GDT");
  x86internals.x86_structs->add("LDT");
  x86internals.x86_structs->add("IDT");
  x86internals.x86_structs->add("TSS");
  // Show the window
  main_window->show(argc, argv);

  // Start the FLTK event loop
  return Fl::run();
}
